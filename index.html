<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js GLB Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        .controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            max-width: 300px;
        }

        .model-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }

        .error {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            display: none;
            max-width: 400px;
        }

        .zoom-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .cursor-indicator {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .cursor-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .cursor-indicator.active {
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
</head>

<body>
    <canvas id="three-canvas"></canvas>

    <div class="controls-info">
        <strong>Controls:</strong><br>
        • Click and Hold: Zoom in<br>
        • Hold + Move Mouse: Rotate camera<br>
        • Mouse Move (no click): Model follows mouse<br>
        • R Key: Reset camera position
    </div>

    <div class="model-info">
        <strong>Model:</strong> <span id="model-name">Default Cube</span><br>
        <strong>Status:</strong> <span id="model-status">Ready</span>
    </div>

    <div class="cursor-indicator" id="cursor-indicator"></div>
    <div class="zoom-indicator" id="zoom-indicator">Press & Hold</div>
    <div class="loading" id="loading">Loading GLB model...</div>
    <div class="error" id="error"></div>

    <!-- Load Three.js and GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script type="module">
        // Scene setup
        import { MeshoptDecoder } from 'https://unpkg.com/three@0.179.0/examples/jsm/libs/meshopt_decoder.module.js';
        const canvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();

        // Create sky background with gradient and clouds
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                topColor: { value: new THREE.Color(0x87CEEB) },    // Sky blue
                bottomColor: { value: new THREE.Color(0xE0F6FF) }, // Light blue
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                uniform float time;
                varying vec3 vWorldPosition;
                
                // Simple noise function for clouds
                float noise(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                
                float fbm(vec2 st) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 2.0;
                    
                    for (int i = 0; i < 4; i++) {
                        value += amplitude * noise(st * frequency + time * 0.1);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));
                    
                    // Add cloud effect
                    vec2 cloudUV = vWorldPosition.xz * 0.001 + time * 0.05;
                    float cloudDensity = fbm(cloudUV);
                    float cloudMask = smoothstep(0.3, 0.8, cloudDensity);
                    
                    // Cloud color
                    vec3 cloudColor = vec3(1.0, 1.0, 1.0);
                    vec3 finalColor = mix(skyColor, cloudColor, cloudMask * 0.7);
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            side: THREE.BackSide
        });

        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Set default front view position
        camera.position.set(0, 2, 8);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;

        // Lighting setup - adjusted for sky environment
        const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.4); // Sky blue ambient
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xFFF8DC, 1.2); // Warm sunlight
        directionalLight.position.set(20, 30, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Add a subtle rim light to enhance the sky feel
        const rimLight = new THREE.DirectionalLight(0xB0E0E6, 0.3);
        rimLight.position.set(-10, 5, -10);
        scene.add(rimLight);

        // Ground plane - more natural grass-like color
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({
            color: 0x567d46,  // Grass green
            transparent: true,
            opacity: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Default cube (will be replaced when GLB is loaded)
        let currentModel = new THREE.Mesh(
            new THREE.BoxGeometry(2, 2, 2),
            new THREE.MeshStandardMaterial({ color: 0xe74c3c })
        );
        currentModel.castShadow = true;
        currentModel.position.y = 1;
        scene.add(currentModel);

        // Camera and model control variables
        let isMouseDown = false;
        let mouseStartPos = { x: 0, y: 0 };
        let currentMousePos = { x: 0, y: 0 };
        let cameraTarget = new THREE.Vector3(0, 1, 0);
        let defaultCameraPos = new THREE.Vector3(0, 2, 8);
        let baseCameraDistance = 8;  // Base distance (100%)
        let currentCameraDistance = 8;
        let zoomStartDistance = 8; // Distance when zoom starts
        let cameraAngleX = 0;
        let cameraAngleY = 0.2;
        let modelRotationX = 0;
        let modelRotationY = 0;
        let isZooming = false;
        let zoomProgress = 0;  // 0 = no zoom, 1 = full 45% zoom

        const cursorIndicator = document.getElementById('cursor-indicator');

        // Mouse event handlers
        canvas.addEventListener('mousedown', (event) => {
            event.preventDefault();
            isMouseDown = true;
            mouseStartPos.x = event.clientX;
            mouseStartPos.y = event.clientY;
            currentMousePos.x = event.clientX;
            currentMousePos.y = event.clientY;

            // Capture current camera distance as zoom start point
            const currentCamPos = camera.position.clone();
            const distanceToTarget = currentCamPos.distanceTo(cameraTarget);
            zoomStartDistance = distanceToTarget;

            // Reset and start zooming
            zoomProgress = 0;  // Reset zoom progress
            isZooming = true;
            document.getElementById('zoom-indicator').style.opacity = '1';
            document.getElementById('zoom-indicator').textContent = 'Zooming...';
            cursorIndicator.classList.add('active');
            canvas.style.cursor = 'zoom-in';
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            isZooming = false;
            document.getElementById('zoom-indicator').style.opacity = '0';
            cursorIndicator.classList.remove('active');
            canvas.style.cursor = 'crosshair';

            // Reset zoom when releasing - return to front view
            zoomProgress = 0;
            currentCameraDistance = baseCameraDistance;
        });

        canvas.addEventListener('mousemove', (event) => {
            currentMousePos.x = event.clientX;
            currentMousePos.y = event.clientY;

            // Update cursor indicator position
            cursorIndicator.style.left = (event.clientX - 30) + 'px';
            cursorIndicator.style.top = (event.clientY - 30) + 'px';

            if (isMouseDown) {
                // Camera rotation while holding
                const deltaX = event.clientX - mouseStartPos.x;
                const deltaY = event.clientY - mouseStartPos.y;

                cameraAngleX = deltaX * 0.01;
                cameraAngleY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, 0.2 - deltaY * 0.01));

                updateCameraPosition();
                canvas.style.cursor = 'move';
            } else {
                // Model follows mouse when not holding
                const rect = canvas.getBoundingClientRect();
                const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Subtle model rotation based on mouse position
                modelRotationX = mouseY * 0.2;
                modelRotationY = mouseX * 0.3;

                if (currentModel) {
                    currentModel.rotation.x = modelRotationX;
                    currentModel.rotation.y = modelRotationY;
                }

                canvas.style.cursor = 'crosshair';
            }
        });

        // Zoom effect while holding mouse - limited to 45% from current position
        function updateZoom() {
            if (isZooming && isMouseDown) {
                // Gradual zoom to 45% from the starting distance
                zoomProgress = Math.min(zoomProgress + 0.025, 1); // Limit to 1 (45% zoom)

                // Calculate zoom distance starting from wherever the camera currently is
                const zoomFactor = 1 - (zoomProgress * 0.45); // 1.0 to 0.55 (45% closer)
                currentCameraDistance = zoomStartDistance * zoomFactor;

                updateCameraPosition();
            }
        }

        // Camera position update
        function updateCameraPosition() {
            if (isMouseDown) {
                // Orbital camera movement
                const x = currentCameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
                const y = currentCameraDistance * Math.sin(cameraAngleY) + cameraTarget.y;
                const z = currentCameraDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);

                camera.position.set(
                    cameraTarget.x + x,
                    y,
                    cameraTarget.z + z
                );
                camera.lookAt(cameraTarget);
            } else {
                // Return to front view when not interacting
                camera.position.lerp(defaultCameraPos, 0.05);
                camera.lookAt(cameraTarget);
            }
        }

        // Reset function
        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'r') {
                baseCameraDistance = 8;
                currentCameraDistance = 8;
                cameraAngleX = 0;
                cameraAngleY = 0.2;
                cameraTarget.set(0, 1, 0);
                defaultCameraPos.set(0, 2, 8);
                modelRotationX = 0;
                modelRotationY = 0;
                zoomProgress = 0;

                if (currentModel) {
                    currentModel.rotation.x = 0;
                    currentModel.rotation.y = 0;
                }

                camera.position.copy(defaultCameraPos);
                camera.lookAt(cameraTarget);
            }
        });

        // GLB Loading function
        function loadGLBModel(url) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('model-status').textContent = 'Loading...';
            document.getElementById('error').style.display = 'none';

            const loader = new THREE.GLTFLoader();
            loader.setMeshoptDecoder(MeshoptDecoder);

            loader.load(
                url,
                function (gltf) {
                    // Remove previous model
                    if (currentModel) {
                        scene.remove(currentModel);
                    }

                    currentModel = gltf.scene;

                    // Enable shadows for all meshes
                    currentModel.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;

                            // Ensure materials work with our lighting
                            if (child.material) {
                                child.material.needsUpdate = true;
                            }
                        }
                    });

                    scene.add(currentModel);

                    // Auto-frame the model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxSize = Math.max(size.x, size.y, size.z);

                    // Position model on ground
                    currentModel.position.y = -box.min.y;

                    // Update camera target and default position
                    cameraTarget.copy(center);
                    cameraTarget.y += size.y * 0.2;

                    const optimalDistance = maxSize * 2.5;
                    baseCameraDistance = optimalDistance;
                    currentCameraDistance = optimalDistance;
                    defaultCameraPos.set(0, cameraTarget.y + size.y * 0.1, optimalDistance);

                    camera.position.copy(defaultCameraPos);
                    camera.lookAt(cameraTarget);

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('model-status').textContent = 'Loaded';
                    document.getElementById('model-name').textContent = url.split('/').pop();

                    console.log('GLB model loaded successfully');
                },
                function (progress) {
                    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
                },
                function (error) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('error').textContent = `Error loading GLB: ${error.message}. Make sure the file path is correct and the file is accessible.`;
                    document.getElementById('model-status').textContent = 'Error';
                    console.error('GLB loading error:', error);
                }
            );
        }

        // Load your GLB file
        loadGLBModel('./models/brandenburg_gate_germany_op.glb');

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Animate the sky clouds
            if (sky && sky.material.uniforms) {
                sky.material.uniforms.time.value += 0.01;
            }

            // Update zoom effect
            updateZoom();

            // Smooth camera transitions
            if (!isMouseDown) {
                updateCameraPosition();
            }

            renderer.render(scene, camera);
        }

        // Initialize
        camera.lookAt(cameraTarget);
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial UI update
        document.getElementById('model-status').textContent = 'Default cube loaded';
    </script>
</body>

</html>