<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Multi-Model GLB Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        .controls-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.4;
            max-width: 300px;
        }

        .model-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .model-item {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
        }

        .model-item.active {
            background: rgba(74, 144, 226, 0.6);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }

        .error {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            display: none;
            max-width: 400px;
        }

        .zoom-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .cursor-indicator {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .cursor-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .cursor-indicator.active {
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        .loading-progress {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            min-width: 300px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4a90e2;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
</head>

<body>
    <canvas id="three-canvas"></canvas>

    <div class="controls-info">
        <strong>Controls:</strong><br>
        • Click and Hold: Zoom into model under cursor<br>
        • Hold + Move Mouse: Rotate camera around model<br>
        • Mouse Move (no click): All models follow mouse<br>
        • R Key: Reset to overview position
    </div>

    <div class="model-info" id="model-info">
        <strong>Models:</strong><br>
        <div class="model-item" data-model="brandenburg">
            <div><strong>Brandenburg Gate</strong></div>
            <div>Status: <span class="status">Loading...</span></div>
        </div>
        <div class="model-item" data-model="model2">
            <div><strong>Model 2</strong></div>
            <div>Status: <span class="status">Loading...</span></div>
        </div>
        <div class="model-item" data-model="model3">
            <div><strong>Model 3</strong></div>
            <div>Status: <span class="status">Loading...</span></div>
        </div>
        <div class="model-item" data-model="model4">
            <div><strong>Model 4</strong></div>
            <div>Status: <span class="status">Loading...</span></div>
        </div>
    </div>

    <div class="cursor-indicator" id="cursor-indicator"></div>
    <div class="zoom-indicator" id="zoom-indicator">Zoom Target: None</div>
    <div class="loading" id="loading">Loading all models...</div>
    <div class="loading-progress" id="loading-progress">
        <div>Loading Models: <span id="progress-text">0/4</span></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>
    <div class="error" id="error"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

        // Scene setup
        const canvas = document.getElementById('three-canvas');
        const scene = new THREE.Scene();

        // Create sky background with gradient and clouds
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                topColor: { value: new THREE.Color(0x87CEEB) },    // Sky blue
                bottomColor: { value: new THREE.Color(0xE0F6FF) }, // Light blue
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                uniform float time;
                varying vec3 vWorldPosition;
                
                // Simple noise function for clouds
                float noise(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                
                float fbm(vec2 st) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 2.0;
                    
                    for (int i = 0; i < 4; i++) {
                        value += amplitude * noise(st * frequency + time * 0.1);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));
                    
                    // Add cloud effect
                    vec2 cloudUV = vWorldPosition.xz * 0.001 + time * 0.05;
                    float cloudDensity = fbm(cloudUV);
                    float cloudMask = smoothstep(0.3, 0.8, cloudDensity);
                    
                    // Cloud color
                    vec3 cloudColor = vec3(1.0, 1.0, 1.0);
                    vec3 finalColor = mix(skyColor, cloudColor, cloudMask * 0.7);
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            side: THREE.BackSide
        });

        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        // Set at a good distance for overview of all models
        camera.position.set(0, 35, 100);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;

        // Lighting setup - adjusted for sky environment
        const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.4); // Sky blue ambient
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xFFF8DC, 1.2); // Warm sunlight
        directionalLight.position.set(20, 30, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Add a subtle rim light to enhance the sky feel
        const rimLight = new THREE.DirectionalLight(0xB0E0E6, 0.3);
        rimLight.position.set(-10, 5, -10);
        scene.add(rimLight);

        // Ground plane - much larger to accommodate the new scale
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshLambertMaterial({
            color: 0x567d46,  // Grass green
            transparent: true,
            opacity: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Model definitions with positions - scattered line formation like a street
        const modelDefinitions = {
            brandenburg: {
                name: 'Brandenburg Gate',
                path: './models/uploads_files_220328_Churche_Frauenkirche_Munich.glb',
                position: new THREE.Vector3(-50, 0, 5), // Left side, slightly forward
                model: null,
                loaded: false,
                boundingBox: null
            },
            model2: {
                name: 'Model 2',
                path: './models/uploads_files_220328_Churche_Frauenkirche_Munich.glb',
                position: new THREE.Vector3(-10, 0, -3), // Left-center, slightly back
                model: null,
                loaded: false,
                boundingBox: null
            },
            model3: {
                name: 'Model 3',
                path: './models/brandenburgGateOp.glb',
                position: new THREE.Vector3(10, 0, 4), // Right-center, slightly forward
                model: null,
                loaded: false,
                boundingBox: null
            },
            model4: {
                name: 'Model 4',
                path: './models/Frauenkirche_Munich_-_View_from_Peterskirche_Tower2_op.glb',
                position: new THREE.Vector3(30, 0, -2), // Right side, slightly back
                model: null,
                loaded: false,
                boundingBox: null
            }
        };

        // Camera and control variables
        let isMouseDown = false;
        let mouseStartPos = { x: 0, y: 0 };
        let currentMousePos = { x: 0, y: 0 };
        let defaultCameraPos = new THREE.Vector3(0, 35, 100);
        let cameraTarget = new THREE.Vector3(0, 8, 0);
        let activeModel = null; // Currently focused model for zoom
        let zoomStartDistance = 20;
        let isZooming = false;
        let zoomProgress = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0.3;

        const cursorIndicator = document.getElementById('cursor-indicator');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Progress tracking
        let loadedModels = 0;
        const totalModels = 4;

        function updateProgress() {
            loadedModels++;
            const progress = (loadedModels / totalModels) * 100;
            document.getElementById('progress-text').textContent = `${loadedModels}/${totalModels}`;
            document.getElementById('progress-fill').style.width = `${progress}%`;

            if (loadedModels === totalModels) {
                setTimeout(() => {
                    document.getElementById('loading-progress').style.display = 'none';
                }, 500);
            }
        }

        // Create fallback models for failed loads
        function createFallbackModel(position, color = 0xe74c3c, modelDef) {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshStandardMaterial({ color });
            const model = new THREE.Mesh(geometry, material);
            model.castShadow = true;
            model.position.copy(position);
            model.position.y = 1;
            model.userData.rootModel = modelDef; // Add the reference
            return model;
        }

        // Initialize GLTF Loader with Meshopt support
        const loader = new GLTFLoader();

        // Set up Meshopt decoder - this is crucial for compressed GLB files
        loader.setMeshoptDecoder(MeshoptDecoder);

        // GLB Loading function
        function loadGLBModel(modelKey) {
            const modelDef = modelDefinitions[modelKey];
            if (!modelDef) return;

            loader.load(
                modelDef.path,
                function (gltf) {
                    modelDef.model = gltf.scene;
                    modelDef.loaded = true;

                    if (modelKey === 'brandenburg') {
                        modelDef.model.rotation.z = -Math.PI / 2;
                    }


                    // Enable shadows for all meshes
                    modelDef.model.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.userData.rootModelDef = modelDef; // <--- The new line
                            if (child.material) {
                                child.material.needsUpdate = true;
                            }
                        }
                    });

                    scene.add(modelDef.model);

                    // Calculate bounding box and position model
                    const box = new THREE.Box3().setFromObject(modelDef.model);
                    modelDef.center = box.getCenter(new THREE.Vector3());
                    modelDef.boundingBox = box;
                    const size = box.getSize(new THREE.Vector3());

                    // Scale down large models if needed
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const minSize = Math.min(size.x, size.y, size.z);

                    if (minSize < 5) {
                        const scaleUp = 2 / minSize;
                        modelDef.model.scale.setScalar(scaleUp);
                    }

                    if (maxSize > 15) { // If model is larger than 15 units
                        const scale = 15 / maxSize;
                        modelDef.model.scale.setScalar(scale);
                    }

                    // Position model on ground at designated position with slight random rotation
                    modelDef.model.position.copy(modelDef.position);
                    modelDef.model.position.y = -box.min.y * (modelDef.model.scale.x || 1);

                    // Add slight random rotation to make it look more natural
                    modelDef.model.rotation.y = (Math.random() - 0.5) * 0.3;

                    // Update UI
                    const modelItem = document.querySelector(`[data-model="${modelKey}"] .status`);
                    if (modelItem) modelItem.textContent = 'Ready';

                    updateProgress();
                    console.log(`GLB model ${modelKey} loaded successfully`);
                },
                function (progress) {
                    // Optional: Update individual model progress
                    if (progress.lengthComputable) {
                        const percent = (progress.loaded / progress.total) * 100;
                        console.log(`Loading ${modelKey}: ${percent.toFixed(1)}%`);
                    }
                },
                function (error) {
                    console.error(`GLB loading error for ${modelKey}:`, error);

                    // Create fallback model
                    const colors = [0xe74c3c, 0x3498db, 0x2ecc71, 0xf39c12]; // Different colors for each fallback
                    const colorIndex = Object.keys(modelDefinitions).indexOf(modelKey);
                    const fallbackModel = createFallbackModel(modelDef.position, colors[colorIndex]);

                    modelDef.model = fallbackModel;
                    modelDef.loaded = true;
                    scene.add(fallbackModel);

                    // Update UI
                    const modelItem = document.querySelector(`[data-model="${modelKey}"] .status`);
                    if (modelItem) modelItem.textContent = 'Fallback';

                    updateProgress();
                }
            );
        }

        // Find which model is under the mouse cursor
        function getModelUnderMouse(mouseX, mouseY) {
            mouse.x = (mouseX / window.innerWidth) * 2 - 1;
            mouse.y = -(mouseY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const models = Object.values(modelDefinitions)
                .filter(def => def.model)
                .map(def => def.model);

            const intersects = raycaster.intersectObjects(models, true);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                // Check if the hit object has the tag we added earlier.
                if (hitObject.userData.rootModelDef) {
                    const modelDef = hitObject.userData.rootModelDef;
                    // Now find the corresponding key in modelDefinitions
                    for (const [key, def] of Object.entries(modelDefinitions)) {
                        if (def === modelDef) {
                            return key;
                        }
                    }
                }
            }

            return null;
        }



        // Mouse event handlers
        canvas.addEventListener('mousedown', (event) => {
            event.preventDefault();
            isMouseDown = true;
            mouseStartPos.x = event.clientX;
            mouseStartPos.y = event.clientY;

            // Determine which model to zoom into
            activeModel = getModelUnderMouse(event.clientX, event.clientY);
            console.log(activeModel);


            if (activeModel) {
                const modelDef = modelDefinitions[activeModel];
                const currentCamPos = camera.position.clone();
                const modelCenter = modelDef.position.clone();
                modelCenter.y += 2; // Adjust for model height
                zoomStartDistance = currentCamPos.distanceTo(modelCenter);

                // Update UI
                document.getElementById('zoom-indicator').textContent = `Zooming: ${modelDef.name}`;
                document.querySelector(`[data-model="${activeModel}"]`).classList.add('active');
            }

            zoomProgress = 0;
            isZooming = true;
            document.getElementById('zoom-indicator').style.opacity = '1';
            cursorIndicator.classList.add('active');
            canvas.style.cursor = 'zoom-in';
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            isZooming = false;
            document.getElementById('zoom-indicator').style.opacity = '0';
            cursorIndicator.classList.remove('active');
            canvas.style.cursor = 'crosshair';

            // Clear active model highlight
            document.querySelectorAll('.model-item').forEach(item => {
                item.classList.remove('active');
            });

            // Reset zoom
            zoomProgress = 0;
            activeModel = null;
        });

        canvas.addEventListener('mousemove', (event) => {
            currentMousePos.x = event.clientX;
            currentMousePos.y = event.clientY;

            // Update cursor indicator position
            cursorIndicator.style.left = (event.clientX - 30) + 'px';
            cursorIndicator.style.top = (event.clientY - 30) + 'px';

            if (isMouseDown && activeModel) {
                // Camera rotation around active model while holding
                const deltaX = event.clientX - mouseStartPos.x;
                const deltaY = event.clientY - mouseStartPos.y;

                cameraAngleX = deltaX * 0.01;
                cameraAngleY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, 0.3 - deltaY * 0.01));

                updateCameraPosition();
                canvas.style.cursor = 'move';
            } else if (!isMouseDown) {
                // All models follow mouse when not holding
                const rect = canvas.getBoundingClientRect();
                const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Apply rotation to all loaded models
                Object.values(modelDefinitions).forEach(def => {
                    if (def.model) {
                        def.model.rotation.x = mouseY * 0.1;
                        def.model.rotation.y = mouseX * 0.15;
                    }
                });

                canvas.style.cursor = 'crosshair';
            }
        });

        // Zoom effect
        function updateZoom() {
            if (isZooming && isMouseDown && activeModel) {
                zoomProgress = Math.min(zoomProgress + 0.02, 1);
                updateCameraPosition();
            }
        }

        // Camera position update
        function updateCameraPosition() {
            if (isMouseDown && activeModel) {
                const modelDef = modelDefinitions[activeModel];
                const targetPos = modelDef.position.clone();
                targetPos.y += 2;

                // Zoom closer to the active model
                const zoomFactor = 1 - (zoomProgress * 0.88); // Zoom in up to 85% closer
                const currentDistance = zoomStartDistance * zoomFactor;

                // Orbital camera movement around the active model
                const x = currentDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
                const y = currentDistance * Math.sin(cameraAngleY) + targetPos.y;
                const z = currentDistance * Math.cos(cameraAngleY) * Math.sin(cameraAngleX);

                camera.position.set(
                    targetPos.x + x,
                    y,
                    targetPos.z + z
                );
                camera.lookAt(targetPos);
            } else if (!isMouseDown) {
                // Return to overview position
                camera.position.lerp(defaultCameraPos, 0.02);
                camera.lookAt(cameraTarget);
            }
        }

        // Reset function
        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'r') {
                camera.position.copy(defaultCameraPos);
                camera.lookAt(cameraTarget);
                cameraAngleX = 0;
                cameraAngleY = 0.3;
                zoomProgress = 0;
                activeModel = null;

                // Reset all model rotations
                Object.values(modelDefinitions).forEach(def => {
                    if (def.model) {
                        def.model.rotation.x = 0;
                        def.model.rotation.y = 0;
                    }
                });

                // Clear UI highlights
                document.querySelectorAll('.model-item').forEach(item => {
                    item.classList.remove('active');
                });
            }
        });

        // Load all models after setting up the decoder
        async function initializeViewer() {
            try {
                // Wait for MeshoptDecoder to be ready
                await MeshoptDecoder.ready;
                console.log('MeshoptDecoder initialized successfully');

                // Now load all models
                Object.keys(modelDefinitions).forEach(key => {
                    loadGLBModel(key);
                });
            } catch (error) {
                console.error('Failed to initialize MeshoptDecoder:', error);
                // Fallback: still try to load models (non-compressed ones might work)
                Object.keys(modelDefinitions).forEach(key => {
                    loadGLBModel(key);
                });
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Animate the sky clouds
            if (sky && sky.material.uniforms) {
                sky.material.uniforms.time.value += 0.01;
            }

            // Update zoom effect
            updateZoom();

            // Smooth camera transitions
            updateCameraPosition();

            renderer.render(scene, camera);
        }

        // Initialize everything
        camera.lookAt(cameraTarget);
        initializeViewer();
        animate();

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>